{"task_id": "C/1", "prompt": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()", "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}", "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}", "entry_point": "hello_mmcodeeval", "signature": "char *hello_mmcodeeval()", "docstring": "Return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "instruction": "Write a C function `char *hello_mmcodeeval()` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "C/2", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n\u200b    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n\u200b    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)", "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}", "entry_point": "calculate_triangle_area", "signature": "double calculate_triangle_area(double a, double b, double c)", "docstring": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n", "instruction": "Write a C function `double calculate_triangle_area(double a, double b, double c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n", "level": "easy"}
{"task_id": "C/3", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)", "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}", "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}", "entry_point": "calculate_function_value", "signature": "const char* calculate_function_value(int x)", "docstring": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n", "instruction": "Write a C function `const char* calculate_function_value(int x)` to solve the following problem:\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n", "level": "middle"}
{"task_id": "C/4", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)", "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}", "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "find_max_min", "signature": "void find_max_min(int a, int b, int c, int *max, int *min)", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "instruction": "Write a C function `void find_max_min(int a, int b, int c, int *max, int *min)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "level": "middle"}
{"task_id": "C/5", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)", "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}", "entry_point": "calculate_distance", "signature": "double calculate_distance(double xa, double ya, double xb, double yb)", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n", "instruction": "Write a C function `double calculate_distance(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n", "level": "easy"}
{"task_id": "C/6", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n\u200b    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n\u200b    Returns:\n\u200b    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)", "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}", "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "process_request", "signature": "int process_request(int n)", "docstring": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n", "instruction": "Write a C function `int process_request(int n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n", "level": "easy"}
{"task_id": "C/7", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n\u200b    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\u200b    Returns:\n\u200b    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)", "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "calculate_triangle_area", "signature": "float calculate_triangle_area(int base, int height)", "docstring": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n", "instruction": "Write a C function `float calculate_triangle_area(int base, int height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n", "level": "easy"}
{"task_id": "C/8", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n\u200b    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\u200b    Returns:\n\u200b    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n\u200b         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)", "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "hamming_distance", "signature": "int hamming_distance(int x, int y)", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "instruction": "Write a C function `int hamming_distance(int x, int y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "level": "middle"}
{"task_id": "C/9", "prompt": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)", "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}", "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_odd_numbers", "signature": "int count_odd_numbers(int count, ...)", "docstring": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n", "instruction": "Write a C function `int count_odd_numbers(int count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n", "level": "easy"}
{"task_id": "C/10", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration", "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}", "entry_point": "calculate_even_sum", "signature": "int calculate_even_sum(int *numbers, int size)", "docstring": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n", "instruction": "Write a C function `int calculate_even_sum(int *numbers, int size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n", "level": "easy"}
{"task_id": "C/11", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n\u200b    Args:\n\u200b    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n\u200b    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\u200b    Returns:\n\u200b    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}", "entry_point": "are_intervals_intersecting", "signature": "int are_intervals_intersecting(int a, int b, int c, int d)", "docstring": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "instruction": "Write a C function `int are_intervals_intersecting(int a, int b, int c, int d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "level": "easy"}
{"task_id": "C/12", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}", "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}", "entry_point": "extraNumber", "signature": "int extraNumber(int a, int b, int c)", "docstring": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n", "instruction": "Write a C function `int extraNumber(int a, int b, int c)` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n", "level": "easy"}
{"task_id": "C/13", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "calculate_total_score", "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "docstring": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n", "instruction": "Write a C function `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n", "level": "easy"}
{"task_id": "C/14", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}", "entry_point": "decode_numbers", "signature": "int decode_numbers(const char* data_str)", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n", "instruction": "Write a C function `int decode_numbers(const char* data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n", "level": "easy"}
{"task_id": "C/15", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_coloring_methods", "signature": "int count_coloring_methods(int n, int m)", "docstring": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n", "instruction": "Write a C function `int count_coloring_methods(int n, int m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n", "level": "hard"}
{"task_id": "C/16", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\u200b    Parameters:\n- n (int): The number of coin tosses.\n\u200b    Returns:\n\u200b    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_valid_coin_toss_sequences", "signature": "unsigned long long count_valid_coin_toss_sequences(int n)", "docstring": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n\u200b    Returns:\n\u200b    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n", "instruction": "Write a C function `unsigned long long count_valid_coin_toss_sequences(int n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n\u200b    Returns:\n\u200b    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n", "level": "easy"}
{"task_id": "C/17", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\u200b    Parameters:\n- n (unsigned long long): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\u200b    Returns:\n\u200b    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\u200b    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "find_longest_consecutive_ones_length", "signature": "int find_longest_consecutive_ones_length(unsigned long long n)", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n", "instruction": "Write a C function `int find_longest_consecutive_ones_length(unsigned long long n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n", "level": "easy"}
{"task_id": "C/18", "prompt": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n\u200bParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n\u200bReturns:\n\u200bchar*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}", "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}", "entry_point": "create_id", "signature": "char* create_id(const char* word1, const char* word2)", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n", "instruction": "Write a C function `char* create_id(const char* word1, const char* word2)` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n", "level": "hard"}
{"task_id": "C/19", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\u200b    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\u200b    Returns:\n\u200b    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)", "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "count_permutations_of_binary_string", "signature": "int count_permutations_of_binary_string(int n, int m)", "docstring": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\u200b    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\u200b    Returns:\n\u200b    int: The total number of different permutation schemes.\n", "instruction": "Write a C function `int count_permutations_of_binary_string(int n, int m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\u200b    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\u200b    Returns:\n\u200b    int: The total number of different permutation schemes.\n", "level": "hard"}
{"task_id": "C/20", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n\u200b    Answer a series of questions by providing choices A, B, C, or D for each question.\n\u200b    Question 1:\n\u200b    Constants like 1e6 belong to which data type?\n\u200b        A. unsigned int\n\u200b        B. int\n\u200b        C. float\n\u200b        D. double\n\u200b    Question 2:\n\u200b    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n\u200b        A. int\n\u200b        B. long long\n\u200b        C. double\n\u200b        D. None of the above\n\u200b    Question 3:\n\u200b    Which statement about left values in expressions is incorrect?\n\u200b        A. Variable name expressions are left values.\n\u200b        B. Increment operation requires the operand to be a left value.\n\u200b        C. Pointer dereference expressions are left values.\n\u200b        D. Prefix increment operation expressions are left values.\n\u200b    Question 4:\n\u200b    Which statement about functions is incorrect?\n\u200b        A. Formal parameters of a function are local variables.\n\u200b        B. Local variables are allocated space in the stack.\n\u200b        C. The function type is the same as the return value type.\n\u200b        D. A function can call itself from within its body.\n\u200b    Question 5:\n\u200b    Which statement about pointers is incorrect?\n\u200b        A. Subtracting two pointers equals the difference in their address values.\n\u200b        B. Pointer dereference involves resolving based on the pointer's type.\n\u200b        C. int *p[4], p is an array of int pointers.\n\u200b        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()", "canonical_solution": "{\n    return \"DDDBA\";\n}", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "answer_questions", "signature": "const char* answer_questions()", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a C function `const char* answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "C/21", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // \u6c42\u548c\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // \u662f\u67d0\u4e2a\u6574\u6570\u7684\u5e73\u65b9\n}", "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "Is_Square", "signature": "int Is_Square(int length, int squares[])", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n", "instruction": "Write a C function `int Is_Square(int length, int squares[])` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n", "level": "easy"}
{"task_id": "C/22", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}", "entry_point": "find_integers", "signature": "int find_integers(int c, int d)", "docstring": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n", "instruction": "Write a C function `int find_integers(int c, int d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n", "level": "easy"}
{"task_id": "C/23", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "count_acute_triangles", "signature": "int count_acute_triangles(int edges_count, ...)", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n", "instruction": "Write a C function `int count_acute_triangles(int edges_count, ...)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n", "level": "hard"}
{"task_id": "C/24", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "process_integer_and_char", "signature": "char* process_integer_and_char(int integer_value, char char_value)", "docstring": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n", "instruction": "Write a C function `char* process_integer_and_char(int integer_value, char char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n", "level": "middle"}
{"task_id": "C/25", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\u200b    Parameters:\n\u200b    text (str): The input text to be processed.\n\u200b\n\u200b    Returns:\n\u200b    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}", "entry_point": "shift_characters", "signature": "char* shift_characters(char* text)", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\u200b    Parameters:\n\u200b    text (str): The input text to be processed.\n\n\u200b    Returns:\n\u200b    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "instruction": "Write a C function `char* shift_characters(char* text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\u200b    Parameters:\n\u200b    text (str): The input text to be processed.\n\n\u200b    Returns:\n\u200b    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "level": "easy"}
{"task_id": "C/26", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\u200b    Returns:\n\u200b    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}", "entry_point": "classify_integer", "signature": "int classify_integer(char *x)", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n", "instruction": "Write a C function `int classify_integer(char *x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n", "level": "easy"}
{"task_id": "C/27", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}", "entry_point": "transform_letter_case", "signature": "char transform_letter_case(char letter)", "docstring": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n", "instruction": "Write a C function `char transform_letter_case(char letter)` to solve the following problem:\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n", "level": "easy"}
{"task_id": "C/28", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n\u200b    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\u200b    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "canonical_solution": "return character;\n}", "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "display_ascii_info", "signature": "int display_ascii_info(char character)", "docstring": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n", "instruction": "Write a C function `int display_ascii_info(char character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n", "level": "easy"}
{"task_id": "C/29", "prompt": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n\u200b\u200b    char: The grade corresponding to the input score.\n\u200b\u200b         If the score is between 90 and 100 (inclusive), returns 'A'.\n\u200b\u200b         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}", "entry_point": "evaluate_integer_grade", "signature": "char evaluate_integer_grade(int score)", "docstring": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n", "instruction": "Write a C function `char evaluate_integer_grade(int score)` to solve the following problem:\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n", "level": "easy"}
{"task_id": "C/30", "prompt": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n\u200b\nArgs:\n    s (char array): The three-character string to be checked.\n\u200b\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "check_two_equal_digits", "signature": "const char* check_two_equal_digits(const char s[4])", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n", "instruction": "Write a C function `const char* check_two_equal_digits(const char s[4])` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n", "level": "easy"}
{"task_id": "C/31", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}", "entry_point": "minRoundsToSameChar", "signature": "int minRoundsToSameChar(const char* s)", "docstring": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n", "instruction": "Write a C function `int minRoundsToSameChar(const char* s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n", "level": "middle"}
{"task_id": "C/32", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}", "entry_point": "apocalypseYear", "signature": "int apocalypseYear(int n, int signs[])", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n", "instruction": "Write a C function `int apocalypseYear(int n, int signs[])` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n", "level": "easy"}
{"task_id": "C/33", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}", "entry_point": "newModuloFactorial", "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "docstring": "This problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n", "instruction": "Write a C function `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n", "level": "easy"}
{"task_id": "C/34", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}", "entry_point": "makeEqualAgain", "signature": "int makeEqualAgain(int n, int a[])", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n", "instruction": "Write a C function `int makeEqualAgain(int n, int a[])` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n", "level": "middle"}
{"task_id": "C/35", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}", "entry_point": "gameWinner", "signature": "const char* gameWinner(int n, int piles[])", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n", "instruction": "Write a C function `const char* gameWinner(int n, int piles[])` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n", "level": "middle"}
{"task_id": "C/36", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}", "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}", "entry_point": "minTotalCost", "signature": "long long minTotalCost(int n, int *C)", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "instruction": "Write a C function `long long minTotalCost(int n, int *C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "level": "easy"}
{"task_id": "C/37", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}", "entry_point": "countHandshakes", "signature": "long long countHandshakes(int n, int order[])", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n", "instruction": "Write a C function `long long countHandshakes(int n, int order[])` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n", "level": "middle"}
{"task_id": "C/38", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}", "entry_point": "maxModeSum", "signature": "long long maxModeSum(int n, const int* counts)", "docstring": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "instruction": "Write a C function `long long maxModeSum(int n, const int* counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "level": "easy"}
{"task_id": "C/39", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}", "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}", "entry_point": "sumOfXorSubarrays", "signature": "long long sumOfXorSubarrays(int A[], int n)", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "instruction": "Write a C function `long long sumOfXorSubarrays(int A[], int n)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "level": "middle"}
{"task_id": "C/40", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}", "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}", "entry_point": "countPowerNumbers", "signature": "int countPowerNumbers(int n, int k)", "docstring": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a C function `int countPowerNumbers(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "level": "hard"}
{"task_id": "C/41", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "countBalancedSubsequences", "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a C function `long long countBalancedSubsequences(long long n, long long m, long long k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "level": "hard"}
{"task_id": "C/42", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "expectedCuts", "signature": "long long expectedCuts(int n, int m, long long k)", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "instruction": "Write a C function `long long expectedCuts(int n, int m, long long k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "level": "hard"}
{"task_id": "C/43", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "countPermutations", "signature": "int countPermutations(int n, int k, int qq[])", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "instruction": "Write a C function `int countPermutations(int n, int k, int qq[])` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "level": "hard"}
{"task_id": "C/44", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}", "entry_point": "countTriplets", "signature": "int countTriplets(int heights[], int n)", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n", "instruction": "Write a C function `int countTriplets(int heights[], int n)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n", "level": "hard"}
{"task_id": "C/45", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}", "entry_point": "minOperations", "signature": "int minOperations(int n, int* pixels)", "docstring": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "instruction": "Write a C function `int minOperations(int n, int* pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "level": "hard"}
{"task_id": "C/46", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}", "entry_point": "sumOfMultiples", "signature": "int sumOfMultiples(int n)", "docstring": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "instruction": "Write a C function `int sumOfMultiples(int n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "level": "easy"}
{"task_id": "C/47", "prompt": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "isPalindrome", "signature": "bool isPalindrome(const char* str)", "docstring": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n", "instruction": "Write a C function `bool isPalindrome(const char* str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n", "level": "middle"}
{"task_id": "C/48", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)", "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}", "entry_point": "addDigits", "signature": "int addDigits(int num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a C function `int addDigits(int num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "C/49", "prompt": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}", "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}", "entry_point": "canWinNim", "signature": "bool canWinNim(int n)", "docstring": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "instruction": "Write a C function `bool canWinNim(int n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "level": "easy"}
{"task_id": "C/50", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}", "entry_point": "evenSumOrOddProduct", "signature": "int evenSumOrOddProduct(int a, int b)", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n", "instruction": "Write a C function `int evenSumOrOddProduct(int a, int b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n", "level": "easy"}
